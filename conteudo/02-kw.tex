\chapter{Kernel Workflow}

Atualmente, considerada toda a complexidade envolvida em um sistema operacional, desenvolver para o kernel Linux pode ser uma tarefa extremamente desafiadora para a maioria dos desenvolvedores. Além do conhecimento teórico sobre a arquitetura do sistema, diversos conhecimentos práticos precisam ser empregados antes que qualquer contribuição possa, de fato, ser iniciada. A exemplo, por se tratar do núcleo de um sistema operacional, o domínio de ferramentas e técnicas para criação de ambientes seguros de teste, como o uso de máquinas virtuais e ambientes isolados, se fazem necessários para validar alterações sem comprometer o sistema principal do desenvolvedor. Além disso, é preciso saber construir e implantar esses ambientes — envolvendo etapas de build e deploy — de modo a reproduzir com precisão o comportamento do kernel em diferentes cenários e arquiteturas dos computadores.

Tendo conhecimento desses fatos, diversas ferramentas são construídas pela comunidade para automatização desses fluxos. Dentre elas, o \textit{Kworkflow} (kw)\footnote{O repositório do projeto está disponível em \url{https://github.com/kworkflow/kworkflow} e o seu sítio oficial em \url{https://kworkflow.org/}.} é uma ferramenta de software livre, desenvolvida principalmente em Bash, que surge com o objetivo de apresentar uma solução unificada para as diversas dificuldades que desenvolvedores do kernel podem encontrar.  Além de automatizar o workflow de desenvolvimento de patches, um dos objetivos do kw é se constituir também como um software científico, permitindo que pesquisadores de Engenharia de Software e áreas correlatas estudem o desenvolvimento do kernel Linux de forma empírica e próxima da prática.

Para que o kw cumpra esse papel científico, é necessário que ele forneça mecanismos de coleta e registro de dados do processo de contribuição, garanta rastreabilidade das alterações e interações entre desenvolvedores, possibilite a reconstrução de cenários de revisão de código e permita a análise estatística ou qualitativa dos fluxos de trabalho. Essas funcionalidades tornam possível investigar padrões de colaboração, eficiência de processos, dificuldades enfrentadas pelos contribuidores e comportamento de manutenção de software de larga escala, transformando o kw em uma ferramenta de pesquisa robusta, além de um utilitário prático para o desenvolvimento de patches. Promovendo assim um ambiente de desenvolvimento mais simples e rápido, reduzindo a carga de conhecimento prévio necessária para novos desenvolvedores e consolidando um meio pelo qual seja possível medir de forma precisa o ciclo de contribuição. Possibilitando ainda que novas soluções possam ser planejadas e que o impacto real das ferramentas já empregadas seja mensurado.

\section{Arquitetura}
Para que o software seja capaz de agrupar tantas ferramentas, o kw segue uma organização estrutural específica em 5 partes:

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{kw-architecture}
    \caption{Arquitetura conceitual do kw\ \small \textit{Fonte: \cite{tadokoro2025kworkflowSBES}}}
    \label{fig:kw-architecture}
\end{figure}

\begin{enumerate} 
    \item \textbf{Hub}: Para permitir que todas as ferramentas do kw sejam oferecidas através de uma interface única, o software utiliza-se de um arquivo central, o \textit{kw.sh}. Esse arquivo atua como um hub — representado pela cor verde na Figura~\ref{fig:kw-architecture} — sendo o responsável por receber os comandos iniciais dos usuários no terminal e redirecionar a execução para a ferramenta especificada.
    \item \textbf{Componentes}: Cada ferramenta do kw possui um arquivo principal que contém o processamento central do comando. Esta camada corresponde à seção azul denominada \textit{FEATURES} na Figura~\ref{fig:kw-architecture}, incluindo a lista de comandos específicos para cada funcionalidade e uma seção de ajuda para orientação dos usuários.
    \item \textbf{Bibliotecas}: O kw utiliza um esquema de bibliotecas para permitir o compartilhamento de código genérico entre diferentes ferramentas. Conforme ilustrado na seção amarela (\textit{LIBRARIES}) da Figura~\ref{fig:kw-architecture}, essas implementações são agrupadas por similaridade de contexto, como manipulação de textos, operações em banco de dados ou tratamento de data e hora.
    \item \textbf{Plugins}: Códigos dependentes de contextos externos ou com alta volatilidade de desenvolvimento são isolados em arquivos específicos. Estes plugins, identificados na cor vermelha (\textit{PLUGINS}) na Figura~\ref{fig:kw-architecture}, permitem que o código principal permaneça estável, aproveitando os métodos declarados independentemente das alterações nas implementações internas desses plugins.
    \item \textbf{Documentação}: Para manter o registro das implementações e informações necessárias para colaboradores, o kw mantém um sistema de documentação, que também é utilizado para a construção do blog da ferramenta. \end{enumerate}

\section{Funcionalidades}

Para compor o seu ferramental e permitir um ambiente holístico, o kw utiliza-se da integração e simplificação de automações consolidadas na comunidade, como o Git, Lore, b4, e outros, desenvolvendo soluções locais quando necessário. De acordo com \cite{tadokoro2023kwlore}, as automações desenvolvidas para o kw dividem-se em dois tipos, as \textit{práticas} e as \textit{indiretas}. As implementações práticas afetam diretamente o desenvolvimento do kernel, como o \textit{kw build} e o \textit{kw deploy}, utilizados para a criação e aplicação da imagem com as alterações do desenvolvedor. Adicionalmente, existem as ferramentas indiretas, que impactam o fluxo de trabalho de forma abrangente, como o \textit{kw send-patch} e o \textit{kw-patch hub}, voltados, respectivamente, à submissão e consulta de \textit{patches} no \textit{lore}.

Por se tratar de uma ferramenta de terminal, os comandos do kw precisam ser invocados de forma escrita pelo usuário, seguindo, a seguinte estrutura: \textit{kw <comando> <parâmetros>}. Até o momento, as principais funcionalidades existentes na ferramenta, são:

\begin{table}[H]
    \caption{comandos do kw. Fonte: Reproduzido de \cite[p.~4]{tadokoro2025kworkflowSBES}}
    \label{tab:kw-commands}
    \begin{center}
    \begin{tabular}{|p{0.2\columnwidth}|p{0.30\columnwidth}|p{0.40\columnwidth}|}
        \hline
        \rowcolor{gray!20}
        \textbf{Command} & \textbf{Category} & \textbf{Description} \\\hline
        \texttt{build}    & kernel build/deploy    & Build kernel and modules \\\hline
        \texttt{deploy}    & kernel build/deploy    & Deploy kernel and modules \\\hline
        \texttt{kernel\-config\-manager}    & kernel build/deploy    & Manage \texttt{.config} files \\\hline
        \texttt{env}    & kernel build/deploy    & Manage different environments for same kernel tree \\\hline
        \texttt{bd}    & kernel build/deploy    & Build and Deploy kernel and modules \\\hline
        \texttt{send-patch}    & patch submission    & Send patches via email \\\hline
        \texttt{maintainers}    & patch submission    & \texttt{get\_maintai\-ners.pl} wrapper \\\hline
        \texttt{codestyle}    & patch submission    & \texttt{checkpatch.pl} wrapper \\\hline
        \texttt{remote}    & target machine    & Manage machines in the network \\\hline
        \texttt{vm}    & target machine    & QEMU wrapper \\\hline
        \texttt{ssh}    & target machine    & \texttt{ssh} wrapper \\\hline
        \texttt{device}    & target machine    & Show hardware information \\\hline
        \texttt{debug}    & code inspection    & Linux debug utilities \\\hline
        \texttt{explore}    & code inspection    & Explore string patterns \\\hline
        \texttt{diff}    & code inspection    & Diff files \\\hline
        \texttt{init}    & kw management    & Initialize kw kernel tree \\\hline
        \texttt{config}    & kw management    & Set kw configs \\\hline
        \texttt{self-update}    & kw management    & Self-update mechanism \\\hline
        \texttt{backup}    & kw management    & Save and restore kw data \\\hline
        \texttt{clear-cache}    & kw management    & Clear kw cache \\\hline
        \texttt{patch-hub}    & misc    & TUI for patches from lore.kernel.org \\\hline
        \texttt{drm}    & misc    & DRM specific utilities \\\hline
        \texttt{pomodoro}    & misc    & Pomodoro technique \\\hline
        \texttt{report}    & misc    & Show usage statistics \\\hline
    \end{tabular}
    \end{center}
\end{table}

Apesar da grande estrutura, compreender de forma completa o fluxo do desenvolvedor do kernel ainda é um desafio que o kw busca superar, estando em constante processo de desenvolvimento por parte da sua comunidade. Um dos processos em abertos, é o de conseguir automatizar o fluxo de gestão dos patches após a submissão e antes da aprovação, na qual os patches passam pelo processo de revisão por parte dos mantenedores, que se torna um desafio em particular durante a contribuição para o kernel Linux dado o seu modelo de contribuição não trivial por listas de email.
\section{O problema da contribuição no desenvolvimento de software livre}

Um grande desafio encontrado durante a construção de sistemas de software é a dificuldade de conciliar o trabalho simultâneo dos diversos colaboradores, o que envolve a capacidade de coordenar as diferentes versões do projeto e as inúmeras submissões de alteração para a versão principal. Antes do advento dos sistemas de controle de versão, os programadores dependiam de métodos manuais para gerenciar suas modificações de código. Eles costumavam fazer backups regulares de seus arquivos de código ou adotar convenções de nomenclatura para distinguir entre as várias versões. Esse processo era bastante inconsistente e difícil de gerenciar, especialmente quando alguns desenvolvedores estavam trabalhando no mesmo projeto \parencite{devineni2020vcs}.

Gerenciar as versões de um software se torna um problema ainda maior dependendo do tamanho total do software, do número de contribuidores e da quantidade de contribuições sendo realizadas nele de maneira simultânea. No kernel, por exemplo, a versão 6.13, lançada em 19/01/2025, contou com mais de 206 contribuições por dia por parte de 2085 colaboradores, resultando em um código fonte final com mais de 39 milhões de linhas \citep{kernelhistory}. Segundo a tendência, esses números devem seguir aumentando de forma constante conforme novas versões forem sendo desenvolvidas.

Buscando superar parte dessas dificuldades e melhorar o processo colaborativo de desenvolvimento de software, foram desenvolvidos os sistemas de controle de versão. Ainda segundo \cite{devineni2020vcs}, os primeiros Version Control Systems (VCS), permitiam que os desenvolvedores mantivessem um histórico das alterações realizadas nos arquivos, o que facilitava a reversão de mudanças e oferecia visibilidade sobre a evolução do código. No entanto, o potencial colaborativo ainda era limitado, exigindo muitos acordos e gestões manuais por parte dos colaboradores.

Como segunda opção, surgem os \textit{Concurrent Versions System} \textit{(CVS)}, baseados em um modelo de repositório central. Nele, os desenvolvedores podiam obter os arquivos, aplicar suas modificações e submetê-las novamente ao repositório. Esse modelo contribuiu para maior agilidade em equipes de desenvolvimento, ao permitir que várias pessoas trabalhassem simultaneamente na mesma base de código. Ainda assim, em projetos de grande porte ou com equipes distribuídas geograficamente, os sistemas centralizados apresentavam limitações no gerenciamento eficiente do trabalho.

Por fim, surgem os modelos mais utilizados atualmente, os \textit{Distributed Concurrent Versions System} - \textit{DVCS}, como o Git. Esses sistemas, ao contrário da versão anterior, distribuía as cópias do código central entre os desenvolvedores, permitindo um método mais flexível de colaboração. Como cada colaborador poderia ter uma versão local do código, as mudanças realizadas por ele ao código principal poderiam ser administradas localmente antes de serem integradas, permitindo trabalhos offline e que alterações fossem submetidas em lotes ao invés de individualmente.

Contudo, de acordo com \cite{kernelrecipes}, ainda que softwares como \textit{github}\footnote{https://github.com}, \textit{gerrit}\footnote{https://www.gerritcodereview.com} ou outros DVCS possam ser úteis para gerir o fluxo de submissões de softwares menores, eles ainda apresentam muitos problemas para escalar para softwares maiores. Dentre os principais motivos, são citados, por exemplo, a maneira como o fluxo para revisão desses softwares é mais demorado e diminui a produtividade dos mantenedores, a dificuldade de gerenciar e categorizar os inúmeros problemas e submissões com os recursos oferecidos, a maneira como as discussões e comentários dentro da comunidade são pouco acessíveis à outros contribuidores, dificultando a propagação de informação e gerando retrabalho, a dificuldade para que desenvolvedores possam se conectar à listas de discussões e serem notificados sempre que uma novidade relevante ocorra, entre outros. Parte desses problemas da comunidade, porém, ainda segundo \cite{kernelrecipes}, são solucionados ao se substituir os softwares de DVCS por servidores de email, como é feito para a contribuição do kernel.

Essa substituição, entretanto, também apresenta suas dificuldades, uma vez que, sendo um sistema com perspectiva muito mais abrangente, servidores de email não apresentam funcionalidades e melhorias para esse fluxo. Entre os diversos problemas enfrentados pelo usuário, destacam-se principalmente o grande \textit{overhead} inicial para novos contribuidores, a má rastreabilidade do históricos de submissões e revisões, a escalabilidade limitada, sobrecarregando a lista de email de alguns mantenedores, problemas de corrupção de arquivos, e a dificuldade de se capturar métricas. Além disso, é também nesse fluxo que ocorre a revisão dos \textit{patches}, ou seja, a comunicação direta entre desenvolvedores e mantenedores, sendo essencial que as respostas e notificações ocorram de forma rápida, dado que submissões realizadas durante o período de estabilização ou durante a janela de mesclagem precisam ser avaliadas dentro desses períodos fixos de tempo. 

Dada a natureza dessa submissão, em muitos casos, isso implica ainda que os desenvolvedores dependam de ferramentas externas, que ainda precisariam ser configuradas, ou do próprio navegador para checar a lista de e-mails em softwares acessíveis através da web, como o gmail, para responder mensagens e acompanhar o status dos \textit{patches}, sendo um desafio ainda maior quando o endereço de e-mail utilizado para submissões é reutilizado para outros contextos, pois isso aumenta a complexidade de filtrar, organizar e priorizar as mensagens relevantes, gerando ruído na comunicação e dificultando a identificação rápida de respostas e revisões. Por fim, da perspectiva do kw, a dependência de sistemas de email também representa uma fragmentação no fluxo do software e em seu princípio de englobar de forma holística o processo de desenvolvimento. Isso porque o usuário submete alterações pelo Kworkflow, mas precisa recorrer a outros meios para acompanhar revisões e depois retornar para atualizar suas submissões, além de impedir a análise completa do fluxo de contribuição, que é um dos objetivos futuros do projeto.

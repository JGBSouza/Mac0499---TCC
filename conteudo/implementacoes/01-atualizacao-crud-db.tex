\section{CRUD banco de dados}

Para poder dar suporte para suas diversas features, o kw conta com um sistema de banco de dados, desenvolvido em SQLite3, que armazena informações necessárias para o funcionamento,
principalmente, das as ferramentas kw pomodoro e kw patch-hub, além de possuir dados de telemetria sobre a utilização do software pelos usuários. Para garantir a consistência e segurança dos dados entre o banco de dados e a aplicação,
é crucial desenvolver operações que lidem com operações de manipulação, como inserção, leitura, atualização e deleção de dados (conhecidas como CRUD - create, read, update,
delete). Essas operações servem como interface entre as diferentes partes do sistema, permitindo uma interação eficaz e garantindo que os dados sejam gerenciados de forma precisa
e confiável.

Contudo, deixar instruções SQL dispersas diretamente no código de aplicação não é considerado uma boa prática de engenharia de software, pois dificulta a manutenção, a legibilidade
e a evolução do sistema. O ideal é encapsular o acesso ao banco de dados em funções ou camadas de abstração que forneçam operações de mais alto nível.
reduzindo o acoplamento entre a lógica de negócio e as queries.

No caso do KWorkflow, desenvolvido em Bash, tal abordagem é limitada pela própria linguagem, que não dispõe de mecanismos nativos para abstração de consultas SQL. Assim, a interação com o
banco de dados precisa ser realizada diretamente por meio de comandos de script, o que torna essa separação menos natural, embora ainda desejável para organizar e isolar responsabilidades.
 
Para tal, o software contava com algumas funções implementadas que permitiam a interação com o banco de dados mas que não isolavam suficientemente o código e as querys, tornando necessário
o uso de comandos SQL em alguns casos, como no comandos de seleção, que recebiam trechos de comando SQL com a clausula \textit{where},que serve para especificar quais critérios devem atender
os parâmetros que serão selecionados ou removidos. Além disso, especificamente nos comandos de seleção, também foram inseridas alterações que permitem, para essa função, também foi implementado
um parâmetro adicional para permitir o uso do da clausula \textit{ordered\_by}, que permite especificar uma ordenação para os dados retornados com base em um atributo comparável entre eles. Por fim,
essa alteração também permitiu que comparações de desigualdades fossem feitas de forma mais abrangente e ordenada, visto que na função de remoção apenas operações de comparação eram possíveis e que
na função de seleção apenas com o código SQL explícito:

\begin{programruledcaption}{código remove\_from antigo}
    \inputminted[breaklines,fontsize=\footnotesize]{bash}{conteudo/implementacoes/codigos/db/remove_from_antigo.bash}
\end{programruledcaption}

\begin{programruledcaption}{código remove\_from novo}
    \inputminted[breaklines,fontsize=\footnotesize]{bash}{conteudo/implementacoes/codigos/db/remove_from_novo.bash}
\end{programruledcaption}

\begin{programruledcaption}{código select\_from antigo}
    \inputminted[breaklines,fontsize=\footnotesize]{bash}{conteudo/implementacoes/codigos/db/select_from_antigo.bash}
\end{programruledcaption}

\begin{programruledcaption}{código select\_from novo}
    \inputminted[breaklines,fontsize=\footnotesize]{bash}{conteudo/implementacoes/codigos/db/select_from_novo.bash}
\end{programruledcaption}

\begin{programruledcaption}{código generate\_where\_clause utilizado nas novas funções para gerar a cláusula WHERE SQL a partir dos parâmetros passados}
    \inputminted[breaklines,fontsize=\footnotesize]{bash}{conteudo/implementacoes/codigos/db/generate_where_clause.bash}
\end{programruledcaption}

\begin{programruledcaption}{snippet uso função select\_from\_antiga}
    \inputminted[breaklines,fontsize=\footnotesize]{bash}{conteudo/implementacoes/codigos/db/snippet_uso_antigo_select_from.bash}
\end{programruledcaption}

\begin{programruledcaption}{snippet uso função select\_from\_nova}
    \inputminted[breaklines,fontsize=\footnotesize]{bash}{conteudo/implementacoes/codigos/db/snippet_uso_novo_select_from.bash}
\end{programruledcaption}


Além disso, outra implementação desenvolvida nessa etapa, foi a implementação do novo método \textit{update\_into}, que permitia a alteração pontual de algum atributo
dentro de uma entidade do banco de dados e da função \textit{generate\_set\_clause}, utilizada para gerar a clausula set, que define quais conjuntos de atributos serão alterados
e quais os novos valores para esses atributos. Essa implementação também faz uso da função \textit{generate\_where\_clause}, uma vez que na maioria das alterações se faz necessário
especificar qual entidade/conjunto de entidades receberá as alterações.

\begin{programruledcaption}{código update\_into}
    \inputminted[breaklines,fontsize=\footnotesize]{bash}{conteudo/implementacoes/codigos/db/update_into.bash}
\end{programruledcaption}

\begin{programruledcaption}{código generate\_set\_clause utilizado para permitir especificar quais atributos serão alterados e quais serão seus novos valores}
    \inputminted[breaklines,fontsize=\footnotesize]{bash}{conteudo/implementacoes/codigos/db/generate_set_clause.bash}
\end{programruledcaption}

\begin{programruledcaption}{snippet uso função update\_into}
    \inputminted[breaklines,fontsize=\footnotesize]{bash}{conteudo/implementacoes/codigos/db/snippet_update_into_uso.bash}
\end{programruledcaption}
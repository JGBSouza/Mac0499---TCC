%!TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101

%% ------------------------------------------------------------------------- %%

% "\chapter" cria um capítulo com número e o coloca no sumário; "\chapter*"
% cria um capítulo sem número e não o coloca no sumário. A introdução não
% deve ser numerada, mas deve aparecer no sumário. Por conta disso, este
% modelo define o comando "\chapter**".
\chapter**{Introdução}
Computadores são parte central da vida em sociedade, servindo como pilar das relações modernas. Para que isso seja possível, eles dependem de sistemas operacionais, softwares específicos que abstraem o conhecimento do hardware que compõe as máquinas, possibilitando a interação final entre ser humano e computador. Em sua composição, os sistemas operacionais são divididos em diversos componentes específicos, dentre os quais o kernel é considerado a parte central. Esse fato decorre principalmente das responsabilidades atribuídas a ele, que incluem a gestão da alocação de recursos entre programas em execução, a priorização de atividades críticas e o gerenciamento da comunicação entre periféricos e o sistema, permitindo que o computador processe ações do usuário por meio dos dispositivos de entrada, coordene o processamento interno dessas atividades e, por fim, apresente os resultados de forma significativa ao usuário, através dos dispositivos de saída.

Entre os diversos sistemas de kernel existentes, o Linux, desenvolvido por Linus Torvalds em 1991, destaca-se como um dos mais relevantes. Assim como outros softwares livres, o Linux surgiu como uma alternativa à hegemonia dos softwares proprietários, como o Unix, sendo construído de forma colaborativa por uma comunidade de desenvolvedores e disponibilizando livre acesso ao seu código e documentação. O kernel Linux é atualmente o maior projeto de software livre do mundo, utilizado por grandes empresas de tecnologia e computação, contando com diversas distribuições e sendo responsável por aproximadamente 57% dos websites na internet cujos sistemas operacionais puderam ser identificados. Mesmo após mais de três décadas desde seu lançamento, novas versões continuam sendo desenvolvidas e publicadas regularmente, conhecidas como “kernels estáveis”.

Para sustentar esse ciclo contínuo de desenvolvimento, o kernel Linux adota um modelo rigoroso descrito por Feitelson como perpetual development, no qual novas funcionalidades, correções e versões de produção são liberadas continuamente, ao mesmo tempo em que versões mais antigas permanecem em manutenção. Esse modelo é estruturado em três etapas principais. A primeira, denominada janela de mesclagem, corresponde ao período em que as contribuições dos desenvolvedores são enviadas aos mantenedores — integrantes da comunidade responsáveis pela administração das submissões e pela verificação da conformidade com os padrões do projeto. A partir dessas integrações, é lançada uma versão inicial do novo kernel, iniciando-se a segunda etapa, o período de estabilização, durante o qual apenas correções e melhorias incrementais são aceitas. Por fim, ao atingir o nível de qualidade necessário, a versão final é oficialmente lançada, e uma equipe reduzida passa a atuar na manutenção contínua, liberando novas correções enquanto uma nova janela de mesclagem é aberta.

Assim como o kernel, os patches incorporados durante a janela de mesclagem também exigem um processo de preparação que envolve diversas etapas, como o design — em que são definidas as concepções iniciais e as implementações necessárias —, a revisão — em que as contribuições são avaliadas pela comunidade e pelos mantenedores —, e a fase de mesclagem e manutenção, em que o desenvolvedor continua responsável por eventuais ajustes após a integração. Considerando a complexidade inerente a um sistema operacional, desenvolver para o kernel Linux representa um desafio significativo para a maioria dos programadores, em razão do amplo conhecimento prático e teórico exigido.

Com o intuito de reduzir parte dessas dificuldades, a comunidade desenvolveu ferramentas destinadas à automação dos fluxos de trabalho. Entre elas, destaca-se o Kernel Workflow (KW), uma ferramenta de software livre desenvolvida majoritariamente em bash, que tem como objetivo oferecer uma solução unificada para os diversos desafios enfrentados pelos contribuidores do kernel. Para isso, o KW integra e simplifica automações amplamente consolidadas na comunidade, como git, lore e b4, criando soluções locais quando necessário. A ferramenta organiza-se como um hub, recebendo comandos do usuário via linha de comando e redirecionando a execução para o módulo apropriado, de modo a oferecer uma interface única para todo o processo.

Apesar da ampla estrutura já existente, compreender de forma completa o fluxo de contribuição ao kernel continua sendo um desafio que o KW busca superar, permanecendo em constante desenvolvimento pela comunidade. Um dos processos ainda em aberto consiste em automatizar a gestão dos patches após a submissão e antes da aprovação, período em que as contribuições passam pela revisão dos mantenedores — uma etapa particularmente complexa no modelo de contribuição por listas de e-mail adotado pelo projeto Linux.

Um dos grandes desafios no desenvolvimento de sistemas de software é coordenar o trabalho simultâneo de diversos colaboradores, o que envolve a gestão de versões, submissões e atualizações. Antes do surgimento dos sistemas de controle de versão, esse processo era realizado manualmente, com métodos como cópias redundantes e convenções de nomenclatura, o que se mostrava inconsistente e de difícil manutenção. Com a introdução dos Version Control Systems (VCS), tornou-se possível registrar o histórico das alterações e recuperar versões anteriores. A evolução desses sistemas levou ao surgimento dos modelos distribuídos, como o Git, que permitiram maior flexibilidade e paralelismo, possibilitando que cada colaborador mantivesse uma cópia local do código e realizasse integrações controladas de suas modificações.

Mesmo assim, conforme aponta Greg Kroah-Hartman (2016), ferramentas como GitHub e Gerrit, embora adequadas a projetos menores, ainda apresentam limitações quando aplicadas a softwares de grande escala, como o kernel Linux. Entre os principais entraves estão o tempo elevado de revisão, a dificuldade de organização e categorização de problemas, a baixa acessibilidade das discussões internas e a sobrecarga das listas de pendências dos mantenedores. Parte dessas dificuldades é mitigada pelo uso de servidores de e-mail como meio principal de contribuição, que, embora resolvam alguns problemas de escalabilidade, introduzem outros desafios, como o alto custo de entrada para novos desenvolvedores, a rastreabilidade limitada das revisões, a sobrecarga das caixas de entrada, a possibilidade de corrupção de arquivos e a dificuldade de coletar métricas sobre o processo de desenvolvimento. Além disso, a necessidade de recorrer a ferramentas externas, como navegadores ou clientes de e-mail, fragmenta o fluxo de trabalho, afastando-se do princípio do KW de oferecer uma experiência integrada.

A dependência de sistemas de e-mail representa, portanto, uma limitação à proposta do KW de abranger o processo de desenvolvimento de forma holística. O usuário submete suas alterações por meio do KW, mas precisa recorrer a outros meios para acompanhar revisões e retornar à ferramenta para atualizar suas submissões, o que dificulta também a análise completa do fluxo de contribuição — um dos objetivos centrais do projeto.

Considerando esse cenário, este trabalho dá continuidade ao processo de melhoria contínua do KW, iniciado por iniciativas anteriores, como Simplificando o processo de contribuição para o kernel Linux (Neto, 2022) e Integrating the KWorkflow system with the Lore archives: Enhancing the Linux kernel developer interaction with mailing lists (Barros Tadokoro, 2023). A proposta aqui apresentada consiste em oferecer aprimoramentos e automatizações voltadas à gestão de patches durante o processo de revisão, integrando-se às implementações anteriores que introduzem, respectivamente, os fluxos de envio e de consulta de patches.

\label{cap:introducao}

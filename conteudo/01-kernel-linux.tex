%!TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101

\chapter{Fundamentação Teórica}
\label{cap:fundamentacao}

\todo[inline]{Evite começar capítulos direto com seções (e seções direto com subseções, etc.). Mesmo que seja curto, um texto dedicado para o capítulo (ou seção, subseção, etc.), falando sobre o que será feito nele, é imporante.}

\section{Software livre}

No mercado computacional, dois conceitos principais dominam o cenário no que se refere ao desenvolvimento como software proprietário ou software livre.\todo[inline]{Ao invés de dizer que são conceitos, acho melhor falar que são formas ou vertentes de como se desenvolver software.}
Em geral, define-se como software proprietário, o software que é desenvolvido de maneira privada, com apenas a aplicação sendo acessível para usuários. Enquanto que, softwares livres são projetos cujo código fonte é de livre acesso para qualquer um que queira estudar.\todo[inline]{Aqui vale cavar um pouco (não muito) mais a fundo. Trazer as 4 liberdades da Free Software Foundation e como software livre engloba também o movimento Open Source.}

Historicamente, o mercado computacional era dominado por grandes corporações, que detinham o monopólio do processo, conhecimento e recursos necessários para o desenvolvimento do software como um todo, dificultando o ingresso de outros competidores no mercado. Nesse cenário, projetos de software livre surgem como um processo disruptivo, compartilhando o acesso a esse conhecimento, de modo a promover a colaboração e inovação na indústria \parencite{avatavului2023faircomparison}.\todo[inline]{Realmente, o movimento software livre (e de certa forma, o open-source também) surge como uma resposta, mas, bem lá trás, ``todo software era livre'' e só no meio dos anos 70 que começou um movimento pra tornar software coisa proprietária. Pesquisando rápido, tem esse livro do Stallman (\url{https://www.oreilly.com/openbook/opensources/book/stallman.html}) que fala sobre isto e pode ser uma referência.}

Esssa abordagens possuem também grande impacto no modo como essas ferramentas são produzidas, comparativamente, softwares proprietários são geridos por empresas, que contratam equipes fixas de funcionários para trabalhar em período integral e de maneira exclusiva no projeto. Dessa maneira, a decisão quanto às novas implementações para o software são centradas, com o principal objetivo, em muitos casos, sendo o de ganho financeiro. Essa prática, contudo, muitas vezes implica em que o foco constante seja em implementações de novas ferramentas ao invés da melhoria do software como um todo, favorecendo com que esses softwares sejam mais propensos à erros e falhas ocasionais. Por outro lado, a existência de responsáveis legais pelo projeto fazem com que esses softwares contem em grande parte com a existência de um suporte especializado, característica valorizada no mercado corporativo.\todo{Muito bom!}

De maneira contraditória\todo{acho que ``oposta'' é melhor que ``contraditória''}, softwares livres são desenvolvidos de maneira colaborativa, contando com a contribuição voluntária de grandes quantidades de desenvolvedores ao redor do mundo inteiro. Por conta disso, as demandas surgem de forma espontânea, muitas vezes da necessidade do próprio usuário que depende do software para usos pessoais. Essa grande quantidade de contribuidores, aliada à dependência mútua destes com o software, garante atualizações frequentes de segurança e qualidade. Como consequência, esses sistemas tendem a ser menos propensos a erros, mas não contam com um suporte dedicado na maioria dos casos.

Hoje, softwares livres e proprietários\todo{talvez ``[...] modelos de software livre e proprietário [...]''} continuam coexistindo no mercado, sendo constantemente comparados quanto à sua efetividade observada em projetos reais. Porém, a inegável vantagem do conhecimento colaborativo e do grande volume de contribuição que softwares livres conseguem apresentar, fazem com que hoje ele esteja em grande crescente no mercado computacional, sendo o método de desenvolvimento de diversos softwares relevantes mundialmente, como no caso do kernel Linux.\todo[inline]{Vale pontuar que os projetos de software livre são inatamente mais fáceis de se pesquisar, ainda que se deva tomar o mesmo cuidado com ética em pesquisa.}

\subsection{Contribuição em Software Livres}

\todo[inline]{Não acho que o título desta subseção está encaixando bem. Talvez um título linha de ``Gerenciamento de contribuições em projetos de software livre'' (isto é só uma direção; não use assim como escrevi, ficou bem ruim).}

Em projetos de software livre, para que a gestão das contribuições seja possível, os sistemas geralmente contam com uma equipe de \textit{mantenedores}, que é um grupo interno de desenvolvedores que possuem responsabilidade geral pelo código principal.\todo[inline]{``[...] os sistemas'' não encaixou bem. Entendo que você está querendo trazer que no kernel cada subsistema tem um pool de mantenedores, mas isto é bem a exceção.}
Desse modo, para que sejam integradas, as contribuições enviadas\todo{avalie se fica legal ``[...] enviadas por \textit{contribuidores}''} precisam passar por revisões por parte dos mantenedores para garantir que atendam aos requisitos técnicos definidos para o projeto. De acordo com \cite{tan2020scaling}, os mantenedores devem avaliar principalmente se um \textit{patch}\todo{use só contribuição. Guarde (e explique) patch para a 1.2} é necessário, se uma implementação apresenta falhas ou se existem eventuais melhorias na forma como a solução foi feita.

Em alguns casos, principalmente devido ao crescimento dos projetos, torna-se necessário também uma divisão em componentes do sistema principal, de modo que cada parte possui seus mantenedores dedicados. Dessa maneira, para que a contribuição seja feita de maneira correta, os \textit{patches}\todo{use contribuições} precisam ser enviados diretamente para o responsável do subsistema\todo{subsistema também é bem específico do kernel; veja se tem fácil um outra forma mais geral de comunicar o que você quer, senão pode deixar assim mesmo} que será alterado.

\section{O Kernel Linux}

Em um computador, o Sistema Operacional é a parte responsável por lidar com as interações entre o hardware e o software, permitindo, de maneira eficiente, a interação final máquina-usuário. Para que isso seja possível, o sistema operacional precisa ser dividido em diversas partes, dentre essas, o kernel, considerado o núcleo dos sistemas operacionais. Em geral, o kernel é um programa que opera a todo momento e é responsável pelo gerenciamento dos processos do sistema, alocando recursos para outros programas em atividade conforme a necessidade e prioridade de cada um.

Dentre os muitos sistemas de kernels existentes, o kernel Linux é um projeto desenvolvido por Linus Torvalds, em 1991, como alternativa ao Unix, pioneiro no mercado de sistemas operacionais. Hoje, o kernel Linux é o maior projeto de software livre do mundo, utilizado por algumas das maiores empresas de tecnologia, software e computação no mercado, possuindo diversas distribuições e constituindo aproximadamente 57\% dos websites na internet cujos sistemas operacionais puderam ser identificados\footnote{Fonte: \href{https://w3techs.com/technologies/details/os-linux}{https://w3techs.com/technologies/details/os-linux}}.

\todo[inline]{Para esta seção 1.2 (subseções inclusas), use parte do que eu coloquei e sugeri você colocar na intro que fala sobre as mesmas coisas. Onde der/estiver fácil expanda também; aqui é o lugar para discorrer mais lentamente sobre isto.}

\subsection{O Modelo de desenvolvimento do Kernel Linux}

\todo[inline]{Questão de estilo: Neste título de subseção, use kernel e não Kernel. Na 1.2 pode deixar.}

Ainda que tenha sido lançado há mais três décadas, novas versões do kernel Linux continuam sendo lançadas até hoje. Essas versões, chamadas {stable kernels}\todo{entendo a sua intenção, mas stable kernels são só uma parte do universo; acho que é melhor falar ``Cada uma das versões do Linux são contruídas [...]''}, são construídas através da contribuição de diversos desenvolvedores ao redor do mundo, através da submissão de \textit{patches}\todo{aqui explique o que é patch como sendo uma contribuição no formato de email neste contexto de kernel dev (pode ser footnote, fica ao seu critério)} de melhorias que são integrados à versão principal para o desenvolvimento de futuras versões. De acordo com \cite{feit2012perpetual}, esse desenvolvimento do kernel Linux segue um modelo de \textit{perpetual development}, no qual novas funcionalidades, correções e versões de produção são liberadas continuamente, havendo também a manutenção de versões mais antigas.

Segundo a \cite{linux_kernel_documentation}\todo{atualize a URL dessa referência para apontar para a versão mais recente da documentação; use citep ao invés de cite}, esse processo divide-se em três etapas bem distintas, a janela de mesclagem, o período de estabilização e a manutenção contínua:

\todo[inline]{Talvez vale transformar cada um destes parágrafos abaixo em subsubseções ou pelo menos em \textbackslash paragraph\{\}. Vê se fica bom, mas o ponto é que precisa de algum destaque e acho que, em alguns (no primeiro principalmente), vai ter que expandir o parágrafo ou quebrar em mais de um.}

Durante a primeira etapa, a maior parte das alterações serão integradas à nova versão do kernel. Essas mesclagens ocorrem a partir de \textit{patches} que foram previamente preparados\todo{explique essa preparação anterior da primeira parte dos slides do Greg e aquela minha figura que usamos no seu pôster. Você fala aprofunda na 1.2.2, mas já fale um pouco aqui}, testados e coletados. Com base nessa nova versão, o primeiro kernel RC (Release Candidate) será lançado, encerrando a janela de mesclagem e iniciando a próxima etapa. 

Durante a segunda etapa, apenas \textit{patches} que sirvam para correção de \textit{bugs} deverão ser enviados e novas versões de RC serão lançadas periodicamente até que uma versão estável seja atingida. De forma objetiva, uma versão estável é atingida quando todas as regressões, erros conhecidos, superados por versões anteriores e reintroduzidos durante a janela de mesclagem, são corrigidas. 

Contudo, dado o tempo limitado em que as etapas precisam ocorrer, eliminar todas as regressões das versões estáveis nem sempre é um desafio que pode ser atingido. Por conta desse fato, após a criação da versão estável\todo{aqui faz mais sentido falar dos stable kernels}, uma equipe de desenvolvedores é designada para a terceira etapa, a manutenção contínua, lançando novas atualizações ocasionais com correções para essa versão por um período de tempo enquanto a janela de mesclagem se reinicia para a nova versão.

\subsection{Contribuindo para o Kernel Linux} 

\todo[inline]{Questão de estilo: Neste título de subseção, use kernel e não Kernel. Na 1.2 pode deixar.}

Assim como outros softwares livres, o kernel Linux também apresenta uma divisão lógica com base no seu conjuntos de subsistemas, como, por exemplo, os sistema de rede, gerenciamento de memória, dispositivos de vídeo, etc. Dentro desses subsistemas, cada mantenedor responsável administra um repositório de fontes do kernel, gerindo os \textit{patches} enviados ao seu subsistema. Ainda segundo a documentação oficial (\cite{linux_kernel_documentation}), eventualmente, esses subsistemas podem ser identificados de modo que um subsistema principal seja constituído por subsistemas menores, como, por exemplo, o subsistema de rede, que agrega também os repositórios dedicadas a drivers de dispositivos de rede cabeadas e de redes sem fio. Desse modo, além dos \textit{patches} recebidos diretamente por contribuidores, os mantenedores podem receber também receber \textit{patches} já aprovados por outros mantenedores, formando uma cadeia de confiança até que os \textit{patches} cheguem a serem integrados.

Para gerir esse modelo de contribuição, o código do kernel Linux é organizado em um modelo de repositórios separados, conhecidos como \textit{árvores do kernel} (\textit{kernel trees}), contendo versões específicas do projeto, com suas respectivas finalidades e responsáveis. A princípio, cada subsistema do kernel possui uma árvore específica, gerida pelos mantenedores responsáveis pela seção do projeto nas quais novas contribuições aceitas serão acumuladas e testadas previamente. Posteriormente, para que as novas versões sejam construídas, durante a janela de mesclagem, são construídas as árvores \textit{-next}, árvores de integração ramificadas da mainline\todo{não sei se estou confundindo, mas não lembro de você explicar a mainline; puxe o que você fala no final do parágrafo para cá} que integrará as novas submissões dispersas nas árvores de sistema para a nova release. A partir dela, após a janela de mesclagem e durante o período de estabilização, serão criadas as árvores de estabilização, nas quais serão organizads as correções da nova versão até que, por fim, essas alterações venha a ser integradas na árvore principal, mainline, administra diretamente por Linus Torvalds, a versão oficial do kernel.

Assim como o kernel\todo{que nem na intro, não entendi este início}, os \textit{patches} que são incorporados durante a janela de mesclagem precisam ser previamente preparados e, durante esse preparo, passam por algumas etapas. Esse processo, ainda que informal, serve para garantir que cada \textit{patch} possa ser revisado e tenha sua qualidade garantida antes que a alteração seja incorporada ao kernel principal (\cite{linux_kernel_documentation}).

\todo[inline]{Antes de entrar no que você vai falar abaixo, introduza a ideia do workflow de desenvolvimento de patchset. Pode usar aquela minha figura (se não tiver, me pinga que te passo). A enumeração abaixo ficou fera e acho que pode virar algo como ``diretrizes de um contribuidor e seu patchset''.}

Os principais estágios que um \textit{patch} deve passar, são: 

\begin{enumerate}
    \item \textbf{Design}: Nesta etapa, serão levantados os requisitos do \textit{patch} e a forma com que serão atingidos, ou seja, a identificação dos seus objetivos e as necessidades técnicas que devem constar nessa implementação.
    \item \textbf{Revisão antecipada}: Publicação dos \textit{patches} na lista de discussão relevante para que desenvolvedores possam responder com comentários e ajudar a revelar quaisquer problemas iniciais.
    \item \textbf{Revisão mais ampla}: Antes que o \textit{patch} seja considerado para inclusão na versão principal, ele deve ser aceito por um mantenedor de subsistema, que o incluirá nas árvores \textit{-next}. Com essa etapa, revisões mais elaboradas e possíveis problemas de integração com outras implementações poderão ser verificados.
    \item \textbf{Mesclagem e manutenção de longo prazo}: Ainda que o \textit{patch} possa ser mesclado e chegar efetivamente à versão estável do kernel, futuros problemas podem vir a aparecer durante essas fases, dessa forma, o desenvolvedor original deve continuar a assumir a responsabilidade da manutenção do código no futuro.
\end{enumerate}

%!TeX root=../tese.tex
%("dica" para o editor de texto: este arquivo é parte de um documento maior)
% para saber mais: https://tex.stackexchange.com/q/78101

\chapter{Fundamentação Teórica}
\label{cap:fundamentacao}

Este capítulo discute os fundamentos teóricos levantados para a compreensão do funcionamento e da gestão do kernel Linux. Nele, são abordados a estrutura de gestão do projeto e de outros softwares livres, o papel dos mantenedores e o fluxo de desenvolvimento por meio de \textit{patches} e árvores de repositórios. Tais definições estabelecem a base conceitual necessária para detalhar as etapas de integração de código, a organização dos subsistemas e a dinâmica de manutenção contínua do sistema.

\section{Software livre}

No mercado computacional, dois principais modos dominam o cenário no que se refere ao desenvolvimento como software proprietário ou software livre.
Em geral, define-se como software proprietário o software desenvolvido de maneira privada, em que apenas a aplicação é acessível aos usuários. Em contrapartida, o software livre fundamenta-se na garantia de acesso ao código-fonte e é definido por quatro liberdades estabelecidas pela \cite{fsf_software_definition}: a liberdade de executar o programa para qualquer propósito (liberdade 0), de estudar seu funcionamento e adaptá-lo (liberdade 1), de redistribuir cópias (liberdade 2) e de distribuir versões modificadas a terceiros (liberdade 3). Esse conceito abrange também o movimento \textit{Open Source}, que, embora apresente motivações distintas voltadas à eficiência técnica, compartilha o princípio do acesso aberto ao código para viabilizar o desenvolvimento colaborativo e a transparência do projeto

Historicamente, o mercado computacional era dominado por grandes corporações, que detinham o monopólio do processo, conhecimento e recursos necessários para o desenvolvimento do software como um todo, dificultando o ingresso de outros competidores no mercado. Nesse cenário, projetos de software livre surgem como um processo disruptivo, compartilhando o acesso a esse conhecimento, de modo a promover a colaboração e inovação na indústria \parencite{avatavului2023faircomparison}.

Esssa abordagens possuem também grande impacto no modo como essas ferramentas são produzidas, comparativamente, softwares proprietários são geridos por empresas, que contratam equipes fixas de funcionários para trabalhar em período integral e de maneira exclusiva no projeto. Dessa maneira, a decisão quanto às novas implementações para o software são centradas, com o principal objetivo, em muitos casos, sendo o de ganho financeiro. Essa prática, contudo, muitas vezes implica em que o foco constante seja em implementações de novas ferramentas ao invés da melhoria do software como um todo, tornando esses softwares mais propensos a erros e falhas ocasionais. Por outro lado, a existência de responsáveis legais pelo projeto fazem com que esses softwares contem em grande parte com a existência de um suporte especializado, característica valorizada no mercado corporativo.

De maneira oposta, softwares livres são desenvolvidos de maneira colaborativa, contando com a contribuição voluntária de grandes quantidades de desenvolvedores ao redor do mundo inteiro. Por conta disso, as demandas surgem de forma espontânea, muitas vezes da necessidade do próprio usuário que depende do software para usos pessoais. Essa grande quantidade de contribuidores, aliada à dependência mútua destes com o software, garante atualizações frequentes de segurança e qualidade. Como consequência, esses sistemas tendem a ser menos propensos a erros, mas não contam com um suporte dedicado na maioria dos casos.

Hoje, modelos de software livre e proprietário continuam coexistindo no mercado, sendo constantemente comparados quanto à sua efetividade observada em projetos reais. Porém, a inegável vantagem do conhecimento colaborativo e do grande volume de contribuição que softwares livres conseguem apresentar, fazem com que hoje ele esteja em ascenção no mercado computacional, sendo o método de desenvolvimento de diversos softwares relevantes mundialmente, como no caso do kernel Linux.

\subsection{Processo de contribuição em Software Livre}

Em projetos de software livre, para que a gestão das contribuições seja possível, os projetos geralmente contam com uma equipe de \textit{mantenedores}, que é um grupo interno de desenvolvedores que possuem responsabilidade geral pelo código principal.
Desse modo, para que sejam integradas, as contribuições enviadas pelos \textit{contribuidores} precisam passar por revisões por parte dos mantenedores para garantir que atendam aos requisitos técnicos definidos para o projeto. De acordo com \cite{tan2020scaling}, os mantenedores devem avaliar principalmente se uma contribuição é necessária, se uma implementação apresenta falhas ou se existem eventuais melhorias na forma como a solução foi feita.

Em alguns casos, principalmente devido ao crescimento dos projetos, torna-se necessário também uma divisão em componentes do sistema principal, de modo que cada parte possui seus mantenedores dedicados. Dessa maneira, para que as contribuições sejam feitas de maneira correta, elas precisam ser enviadas diretamente para o responsável do subsistema que será alterado.

\section{O Kernel Linux}

Em um computador, o Sistema Operacional é a parte responsável por lidar com as interações entre o hardware e o software, permitindo, de maneira eficiente, a interação final máquina-usuário. Para que isso seja possível, o sistema operacional precisa ser dividido em diversas partes, dentre essas, o kernel, considerado o núcleo dos sistemas operacionais. Em geral, o kernel é um programa que opera a todo momento e é responsável pelo gerenciamento dos processos do sistema, alocando recursos para outros programas em atividade conforme a necessidade e prioridade de cada um.

Dentre os muitos sistemas de kernels existentes, o kernel Linux é um projeto desenvolvido por Linus Torvalds, em 1991, como uma resposta direta à hegemonia e às restrições dos sistemas operacionais proprietários da época. Enquanto o mercado era dominado pelo modelo fechado do Unix, Torvalds propôs uma alternativa fundamentada no livre acesso ao código e na construção descentralizada.

Essa oposição ao modelo proprietário foi um dos motores que permitiu ao Linux escalar através de contribuições globais, superando as limitações de desenvolvimento das empresas tradicionais. Hoje, o kernel Linux é o maior projeto de software livre do mundo, utilizado por algumas das maiores empresas de tecnologia, software e computação no mercado, possuindo diversas distribuições e constituindo aproximadamente 57\% dos websites na internet cujos sistemas operacionais puderam ser identificados\footnote{Fonte: \href{https://w3techs.com/technologies/details/os-linux}{https://w3techs.com/technologies/details/os-linux}}.

\subsection{O Modelo de desenvolvimento do kernel Linux}

Ainda que tenha sido lançado há mais de três décadas, novas versões do kernel Linux continuam sendo lançadas até hoje. Cada uma das versões do Linux é construída através da contribuição de diversos desenvolvedores ao redor do mundo, por meio da submissão de \textit{patches}\footnote{No contexto de desenvolvimento do kernel, um \textit{patch} é um arquivo de texto que descreve as diferenças entre duas versões do código-fonte. Essas contribuições são enviadas via e-mail para listas de discussão públicas, contendo o código alterado e uma descrição das mudanças (o \textit{commit message}), para serem revisadas pelos mantenedores antes da integração.} de melhorias que são integrados à versão principal para o desenvolvimento de futuras versões. De acordo com \cite{feit2012perpetual}, esse desenvolvimento do kernel Linux segue um modelo de desenvolvimento perpétuo, no qual novas funcionalidades, correções e versões de produção são liberadas continuamente, havendo também a manutenção de versões mais antigas.
Segundo a \cite{linux_kernel_documentation}, esse processo divide-se em três etapas bem distintas: a janela de mesclagem, o período de estabilização e a manutenção contínua.

\paragraph{Janela de Mesclagem (Merge Window)} Durante a primeira etapa, a maior parte das alterações será integrada à nova versão do kernel. Essas mesclagens não ocorrem de forma imediata; elas ocorrem a partir de \textit{patches} que foram previamente preparados, testados e coletados em árvores de subsistemas ao longo de semanas ou meses. Esse trabalho prévio de organização pelos mantenedores garante que, ao abrir a janela, o código já tenha passado por um ciclo de maturação inicial. Com base nessa nova versão, o primeiro kernel RC (\textit{Release Candidate}) será lançado, encerrando a janela de mesclagem e iniciando a próxima etapa.

\paragraph{Período de Estabilização} Durante a segunda etapa, apenas \textit{patches} que sirvam para correção de \textit{bugs} deverão ser enviados e novas versões de RC serão lançadas periodicamente até que uma versão estável seja atingida. De forma objetiva, uma versão estável é atingida quando todas as regressões — erros conhecidos que haviam sido superados por versões anteriores e foram reintroduzidos durante a janela de mesclagem — são corrigidas. O foco aqui é estritamente a confiabilidade do código integrado anteriormente.

\paragraph{Manutenção Contínua (Stable Kernels)} Contudo, dado o tempo limitado em que as etapas precisam ocorrer, eliminar todas as regressões das versões estáveis nem sempre é um desafio que pode ser atingido plenamente antes do lançamento. Por conta desse fato, após a criação da versão estável, o projeto entra na fase dos \textit{stable kernels}. Nesta terceira etapa, uma equipe de desenvolvedores é designada para a manutenção contínua, lançando novas atualizações ocasionais (como as revisões pontuais da versão principal) com correções críticas para essa versão por um período de tempo, enquanto a janela de mesclagem se reinicia para a nova versão.

\subsection{Contribuindo para o Kernel Linux} 

Assim como outros softwares livres, o kernel Linux também apresenta uma divisão lógica com base no seu conjuntos de subsistemas, como, por exemplo, os sistema de rede, gerenciamento de memória, dispositivos de vídeo, etc. Dentro desses subsistemas, cada mantenedor responsável administra um repositório de fontes do kernel, gerindo os \textit{patches} enviados ao seu subsistema. Ainda segundo a documentação oficial (\cite{linux_kernel_documentation}), eventualmente, esses subsistemas podem ser identificados de modo que um subsistema principal seja constituído por subsistemas menores, como, por exemplo, o subsistema de rede, que agrega também os repositórios dedicadas a drivers de dispositivos de rede cabeadas e de redes sem fio. Desse modo, além dos \textit{patches} recebidos diretamente por contribuidores, os mantenedores podem receber também receber \textit{patches} já aprovados por outros mantenedores, formando uma cadeia de confiança até que os \textit{patches} cheguem a ser integrados (Figura~\ref{fig:caminho-de-um-patch}).

Para gerir esse modelo de contribuição, o código do kernel Linux é organizado em um modelo de repositórios separados, conhecidos como \textit{árvores do kernel} (\textit{kernel trees}), contendo versões específicas do projeto, com suas respectivas finalidades e responsáveis. A princípio, cada subsistema do kernel possui uma árvore específica, gerida pelos mantenedores responsáveis pela seção do projeto, nas quais novas contribuições aceitas serão acumuladas e testadas previamente. Posteriormente, para que as novas versões sejam construídas, utiliza-se como base a árvore \textit{mainline} — o repositório central e oficial do kernel, administrado diretamente por Linus Torvalds, que contém o código da versão em desenvolvimento e das futuras \textit{releases}. Durante a janela de mesclagem, são construídas as árvores \textit{-next}, que funcionam como árvores de integração ramificadas da \textit{mainline} para reunir as novas submissões dispersas nas diversas árvores de subsistemas. A partir dela, após a janela de mesclagem e durante o período de estabilização, serão criadas as árvores de estabilização, nas quais serão organizadas as correções da nova versão até que, por fim, essas alterações venham a ser consolidadas na árvore \textit{mainline} definitiva.

\begin{figure}[!htbp]
  \centering
    \includegraphics[width=0.7\textwidth]{caminho-de-um-patch}
    \caption{O processo de um patch do kernel \citep{kroah2018linux} \label{fig:caminho-de-um-patch}}
\end{figure}

Em paralelo à execução das etapas formais do ciclo, o desenvolvimento nos subsistemas específicos, a exemplo do IIO e AMD-GFX, ocorre de forma ininterrupta. Antes da submissão aos mantenedores, os contribuidores realizam a validação local dos \textit{patches}, iniciando um fluxo de trabalho que precede a janela de mesclagem. A gestão dessas contribuições pela comunidade e pelos mantenedores envolve ciclos constantes de testes e revisões, assegurando que o código esteja estabilizado para a integração na \textit{mainline}. (\cite{linux_kernel_documentation}).

Os principais estágios que um \textit{patch} deve passar, são: 

\begin{enumerate}
    \item \textbf{Design}: Nesta etapa, serão levantados os requisitos do \textit{patch} e a forma com que serão atingidos, ou seja, a identificação dos seus objetivos e as necessidades técnicas que devem constar nessa implementação.
    \item \textbf{Revisão antecipada}: Publicação dos \textit{patches} na lista de discussão relevante para que desenvolvedores possam responder com comentários e ajudar a revelar quaisquer problemas iniciais.
    \item \textbf{Revisão mais ampla}: Antes que o \textit{patch} seja considerado para inclusão na versão principal, ele deve ser aceito por um mantenedor de subsistema, que o incluirá nas árvores \textit{-next}. Com essa etapa, revisões mais elaboradas e possíveis problemas de integração com outras implementações poderão ser verificados.
    \item \textbf{Mesclagem e manutenção de longo prazo}: Ainda que o \textit{patch} possa ser mesclado e chegar efetivamente à versão estável do kernel, futuros problemas podem vir a aparecer durante essas fases, dessa forma, o desenvolvedor original deve continuar a assumir a responsabilidade da manutenção do código no futuro.
\end{enumerate}
